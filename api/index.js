// Vercel serverless function for Squdy backend (consolidated, ESM)
import express from 'express';
import cors from 'cors';
import { ethers } from 'ethers';
import { randomBytes } from 'crypto';
import { getDatabase } from './lib/mongodb.js';
import { ObjectId } from 'mongodb';
import { ObjectId } from 'mongodb';

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// Health endpoint
app.get(['/api/health', '/health'], async (req, res) => {
  let mongoStatus = 'unknown';
  let mongoError = null;
  let mongoInfo = {};
  
  try {
    if (!process.env.MONGODB_URI) {
      mongoStatus = 'no_uri';
    } else {
      const db = await getDatabase();
      const col = db.collection('campaigns');
      const count = await col.countDocuments({});
      const sample = await col.findOne({});
      mongoStatus = 'connected';
      mongoInfo = {
        dbName: db.databaseName,
        totalCampaigns: count,
        sampleCampaign: sample ? {
          id: sample._id,
          name: sample.name,
          contractId: sample.contractId,
          contractIdType: typeof sample.contractId
        } : null
      };
    }
  } catch (e) {
    mongoStatus = 'error';
    mongoError = e.message;
  }
  
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    mongodb: {
      status: mongoStatus,
      error: mongoError,
      info: mongoInfo
    }
  });
});

// In-memory demo campaigns (ephemeral fallback when DB empty)
const demoCampaigns = [1,2,3,4,5].map((i) => ({
    id: i,
    contractId: i,
    name: `Demo Campaign ${i}`,
    description: 'Demo campaign generated by backend.',
    imageUrl: 'https://images.unsplash.com/photo-1640340434855-6084b1f4901c?w=800&h=400&fit=crop',
    status: 'active',
    currentAmount: 0,
    hardCap: 50000,
    participantCount: 0,
    softCap: 5000,
    ticketAmount: 100,
    startDate: new Date().toISOString(),
    endDate: new Date(Date.now() + 7*24*60*60*1000).toISOString(),
    prizes: [
      { name: 'First Prize', description: 'Winner takes all', value: '10000', currency: 'USD', quantity: 1 },
      { name: 'Second Prize', description: 'Runner up reward', value: '5000', currency: 'USD', quantity: 1 },
      { name: 'Third Prize', description: 'Bronze medal', value: '2500', currency: 'USD', quantity: 1 },
    ],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
}));

let campaignsInMemory = [...demoCampaigns];

async function getCampaignsCollection() {
  const db = await getDatabase();
  return db.collection('campaigns');
}

// Campaigns list
app.get(['/api/campaigns','/campaigns'], async (req, res) => {
  try {
    const limit = parseInt(req.query.limit || '10', 10);
    const page = 1;

    const col = await getCampaignsCollection();
    const raw = await col
      .find({})
      .sort({ createdAt: -1, _id: -1 })
      .limit(limit)
      .toArray();

    // Normalize results so UI always has usable fields
    let campaigns = raw.map((c, idx) => {
      const fallbackId = 1000 + idx;
      const normalizedContractId = typeof c.contractId === 'number' && Number.isFinite(c.contractId)
        ? c.contractId
        : (typeof c.contractId === 'string' && !isNaN(Number(c.contractId)) ? Number(c.contractId) : fallbackId);
      return {
        id: (c._id && c._id.toString) ? c._id.toString() : String(normalizedContractId),
        contractId: normalizedContractId,
        name: c.name ?? 'Untitled Campaign',
        description: c.description ?? '',
        imageUrl: c.imageUrl || 'https://images.unsplash.com/photo-1640340434855-6084b1f4901c?w=800&h=400&fit=crop',
        status: c.status || 'active',
        currentAmount: Number(c.currentAmount || 0),
        hardCap: Number(c.hardCap || 0),
        participantCount: Number(c.participantCount || 0),
        softCap: Number(c.softCap || 0),
        ticketAmount: Number(c.ticketAmount || 0),
        startDate: c.startDate || new Date().toISOString(),
        endDate: c.endDate || new Date(Date.now() + 7*24*60*60*1000).toISOString(),
        prizes: Array.isArray(c.prizes) ? c.prizes : [],
        createdAt: c.createdAt || new Date().toISOString(),
        updatedAt: c.updatedAt || new Date().toISOString(),
      };
    });
    
    // If no valid campaigns from MongoDB, use in-memory as fallback
    if (campaigns.length === 0) {
      campaigns = campaignsInMemory.slice(0, limit);
    }
    
    // MongoDB should now be working with proper MONGODB_URI
    // Only use demo campaigns as absolute fallback if still no campaigns found
    if (campaigns.length === 0) {
      console.log('No campaigns found in MongoDB, using demo fallback');
      campaigns = [{
        id: 998,
        contractId: 998,
        name: "Demo Fallback Campaign",
        description: "This appears when no campaigns exist in MongoDB",
        imageUrl: "https://images.unsplash.com/photo-1640340434855-6084b1f4901c?w=800&h=400&fit=crop",
        softCap: 10000,
        hardCap: 50000,
        ticketAmount: 100,
        currentAmount: 15000,
        startDate: new Date().toISOString(),
        endDate: new Date(Date.now() + 7*24*60*60*1000).toISOString(),
        status: "active",
        participantCount: 25,
        prizes: ["Demo prize pool"],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      }];
    }

    res.set('Cache-Control', 'no-store');
    res.json({
      campaigns,
      pagination: { page, limit, total: campaigns.length, totalPages: 1 }
    });
  } catch (e) {
    console.error('List campaigns error, using fallback:', e);
    // Fallback to in-memory campaigns on any error
    const campaigns = campaignsInMemory.slice(0, parseInt(req.query.limit || '10', 10));
    res.set('Cache-Control', 'no-store');
    res.json({
      campaigns,
      pagination: { page: 1, limit: 10, total: campaignsInMemory.length, totalPages: 1 }
    });
  }
});

// Temporary: alternative list endpoint with relaxed normalization (no numeric contractId requirement)
app.get('/api/campaigns2', async (req, res) => {
  try {
    const limit = parseInt(req.query.limit || '10', 10);
    const col = await getCampaignsCollection();
    const raw = await col
      .find({})
      .sort({ createdAt: -1, _id: -1 })
      .limit(limit)
      .toArray();

    const campaigns = raw.map((c, idx) => ({
      id: (c._id && c._id.toString) ? c._id.toString() : String(idx + 1),
      contractId: typeof c.contractId === 'number' && Number.isFinite(c.contractId)
        ? c.contractId
        : (typeof c.contractId === 'string' && !isNaN(Number(c.contractId)) ? Number(c.contractId) : 1000 + idx),
      name: c.name ?? 'Untitled Campaign',
      description: c.description ?? '',
      imageUrl: c.imageUrl || 'https://images.unsplash.com/photo-1640340434855-6084b1f4901c?w=800&h=400&fit=crop',
      status: c.status || 'active',
      currentAmount: Number(c.currentAmount || 0),
      hardCap: Number(c.hardCap || 0),
      participantCount: Number(c.participantCount || 0),
      softCap: Number(c.softCap || 0),
      ticketAmount: Number(c.ticketAmount || 0),
      startDate: c.startDate || new Date().toISOString(),
      endDate: c.endDate || new Date(Date.now() + 7*24*60*60*1000).toISOString(),
      prizes: Array.isArray(c.prizes) ? c.prizes : [],
      createdAt: c.createdAt || new Date().toISOString(),
      updatedAt: c.updatedAt || new Date().toISOString(),
    }));

    res.set('Cache-Control', 'no-store');
    return res.json({ campaigns, pagination: { page: 1, limit, total: campaigns.length, totalPages: 1 } });
  } catch (e) {
    console.error('campaigns2 error:', e);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Debug: list registered routes
app.get('/api/routes', (req, res) => {
  const routes = [];
  app._router.stack.forEach((middleware) => {
    if (middleware.route) {
      const methods = Object.keys(middleware.route.methods)
        .filter((m) => middleware.route.methods[m])
        .map((m) => m.toUpperCase());
      routes.push({ path: middleware.route.path, methods });
    } else if (middleware.name === 'router' && middleware.handle.stack) {
      middleware.handle.stack.forEach((handler) => {
        const route = handler.route;
        if (route) {
          const methods = Object.keys(route.methods)
            .filter((m) => route.methods[m])
            .map((m) => m.toUpperCase());
          routes.push({ path: route.path, methods });
        }
      });
    }
  });
  res.json({ routes });
});

// Admin stats (Mongo optional)
app.get(['/api/admin/stats','/admin/stats'], async (req, res) => {
  try {
    const stats = {
      platform: { totalCampaigns: 0, activeCampaigns: 0, totalParticipants: 0, totalRaised: 0, status: 'operational' },
      blockchain: {
        network: process.env.VITE_NETWORK || 'sepolia',
        chainId: process.env.VITE_CHAIN_ID || '11155111',
        squdyTokenAddress: process.env.VITE_SQUDY_TOKEN_ADDRESS,
        campaignManagerAddress: process.env.VITE_CAMPAIGN_MANAGER_ADDRESS,
        connected: true,
      },
      database: { status: 'unknown', lastCheck: new Date().toISOString() },
    };
    res.json({ stats });
  } catch (e) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Admin create campaign (mock; ephemeral) - include alternate path to avoid any platform routing quirks
async function handleCreateCampaign(req, res) {
  const data = req.body || {};
  if (!data.name || !data.description || !data.softCap || !data.hardCap || !data.ticketAmount) {
    return res.status(400).json({ error: 'Missing required fields' });
  }
  const nowIso = new Date().toISOString();
  try {
    const col = await getCampaignsCollection();
    const last = await col.find({ contractId: { $type: 'number' } }).sort({ contractId: -1 }).limit(1).toArray();
    const nextId = last.length && typeof last[0].contractId === 'number' ? (last[0].contractId + 1) : Math.floor(Date.now() / 1000);

    const newCampaign = {
      contractId: nextId,
      name: data.name,
      description: data.description,
      imageUrl: data.imageUrl || 'https://images.unsplash.com/photo-1640340434855-6084b1f4901c?w=800&h=400&fit=crop',
      status: 'active',
      currentAmount: 0,
      hardCap: Number(data.hardCap),
      participantCount: 0,
      softCap: Number(data.softCap),
      ticketAmount: Number(data.ticketAmount),
      startDate: data.startDate || nowIso,
      endDate: data.endDate || new Date(Date.now() + 7*24*60*60*1000).toISOString(),
      prizes: data.prizes || [],
      createdAt: nowIso,
      updatedAt: nowIso,
    };

    await col.insertOne(newCampaign);

    // Keep in-memory fallback updated (useful if DB temporarily unavailable later)
    campaignsInMemory = [newCampaign, ...campaignsInMemory];

    res.set('Cache-Control', 'no-store');
    return res.status(201).json({ message: 'Campaign created', campaign: newCampaign });
  } catch (e) {
    console.error('Create campaign error, falling back to memory:', e);
    console.error('MongoDB URI available:', !!process.env.MONGODB_URI);
    console.error('Error details:', e.message);
    const newCampaign = {
      id: campaignsInMemory.length + 1,
      contractId: campaignsInMemory.length + 1,
      name: data.name,
      description: data.description,
      imageUrl: data.imageUrl || 'https://images.unsplash.com/photo-1640340434855-6084b1f4901c?w=800&h=400&fit=crop',
      status: 'active',
      currentAmount: 0,
      hardCap: Number(data.hardCap),
      participantCount: 0,
      softCap: Number(data.softCap),
      ticketAmount: Number(data.ticketAmount),
      startDate: data.startDate || nowIso,
      endDate: data.endDate || new Date(Date.now() + 7*24*60*60*1000).toISOString(),
      prizes: data.prizes || [],
      createdAt: nowIso,
      updatedAt: nowIso,
    };
    campaignsInMemory = [newCampaign, ...campaignsInMemory];
    res.set('Cache-Control', 'no-store');
    return res.status(201).json({ message: 'Campaign created (fallback)', campaign: newCampaign, debug: { mongoUriPresent: !!process.env.MONGODB_URI, error: e.message } });
  }
}

app.post(['/api/admin/campaigns','/admin/campaigns','/api/admin-create-campaign'], (req, res) => {
  return handleCreateCampaign(req, res);
});

// Fallback create on public path to avoid any admin routing quirks on Vercel
app.post(['/api/campaigns','/campaigns'], (req, res) => {
  return handleCreateCampaign(req, res);
});

// Temporary compatibility endpoint to bypass POST issues on Vercel routing
app.get('/api/create-campaign', (req, res) => {
  const data = {
    name: req.query.name,
    description: req.query.description,
    softCap: Number(req.query.softCap),
    hardCap: Number(req.query.hardCap),
    ticketAmount: Number(req.query.ticketAmount),
    startDate: req.query.startDate,
    endDate: req.query.endDate,
  };
  return handleCreateCampaign({ body: data }, res);
});

// Debug route to verify Vercel routing for this path
app.get(['/api/admin/campaigns','/admin/campaigns','/api/admin-create-campaign'], async (req, res) => {
  try {
    const db = await getDatabase();
    const col = db.collection('campaigns');
    const allRaw = await col.find({}).toArray();
    const withName = await col.find({ name: { $exists: true } }).toArray();
    const withNumericId = await col.find({ contractId: { $type: 'number' } }).toArray();
    
    return res.status(200).json({ 
      ok: true, 
      path: req.path,
      debug: {
        totalInDB: allRaw.length,
        withName: withName.length,
        withNumericId: withNumericId.length,
        sampleDocs: allRaw.map(doc => ({
          _id: doc._id,
          name: doc.name,
          contractId: doc.contractId,
          contractIdType: typeof doc.contractId
        }))
      }
    });
  } catch (e) {
    return res.status(200).json({ ok: false, error: e.message });
  }
});

// Allow CORS preflight on admin campaigns path
app.options(['/api/admin/campaigns','/admin/campaigns','/api/admin-create-campaign','/api/campaigns','/campaigns'], (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  return res.status(200).end();
});

// Single campaign
app.get(['/api/campaigns/:id','/campaigns/:id'], async (req, res) => {
  const rawId = req.params.id;
  try {
    const col = await getCampaignsCollection();
    let campaign = null;

    try {
      if (ObjectId.isValid(rawId)) {
        campaign = await col.findOne({ _id: new ObjectId(rawId) });
      }
    } catch (_) {}
    try {
      if (!campaign && !isNaN(Number(rawId))) {
        campaign = await col.findOne({ contractId: Number(rawId) }) || await col.findOne({ id: Number(rawId) });
      }
    } catch (_) {}

    if (campaign) {
      const normalized = {
        id: (campaign._id && campaign._id.toString) ? campaign._id.toString() : String(campaign.id || campaign.contractId || rawId),
        contractId: typeof campaign.contractId === 'number' && Number.isFinite(campaign.contractId)
          ? campaign.contractId
          : (typeof campaign.contractId === 'string' && !isNaN(Number(campaign.contractId)) ? Number(campaign.contractId) : Number(campaign.id) || 0),
        name: campaign.name ?? 'Untitled Campaign',
        description: campaign.description ?? '',
        imageUrl: campaign.imageUrl || 'https://images.unsplash.com/photo-1640340434855-6084b1f4901c?w=800&h=400&fit=crop',
        status: campaign.status || 'active',
        currentAmount: Number(campaign.currentAmount || 0),
        hardCap: Number(campaign.hardCap || 0),
        participantCount: Number(campaign.participantCount || 0),
        softCap: Number(campaign.softCap || 0),
        ticketAmount: Number(campaign.ticketAmount || 0),
        startDate: campaign.startDate || new Date().toISOString(),
        endDate: campaign.endDate || new Date(Date.now() + 7*24*60*60*1000).toISOString(),
        prizes: Array.isArray(campaign.prizes) ? campaign.prizes : [],
        createdAt: campaign.createdAt || new Date().toISOString(),
        updatedAt: campaign.updatedAt || new Date().toISOString(),
      };
      res.set('Cache-Control', 'no-store');
      return res.json({ campaign: normalized });
    }
  } catch (e) {
    console.error('Read single campaign DB error:', e);
  }
  const numId = Number(rawId);
  const fallback = campaignsInMemory.find(c => c.id === numId || c.contractId === numId);
  if (!fallback) return res.status(404).json({ error: 'Campaign not found' });
  res.set('Cache-Control', 'no-store');
  return res.json({ campaign: fallback });
});

// My status for campaign (mock)
app.get(['/api/campaigns/:id/my-status','/campaigns/:id/my-status'], (req, res) => {
  return res.json({ isParticipating: false, status: null, stakeAmount: 0, socialTasks: {} });
});

// Admin maintenance: drop conflicting indexes created earlier (production one-off)
app.post('/api/admin/db-fix-indexes', async (req, res) => {
  try {
    const db = await getDatabase();
    const col = db.collection('campaigns');
    const before = (await col.indexes()).map(ix => ({ name: ix.name, key: ix.key, unique: !!ix.unique }));

    const names = new Set(before.map(ix => ix.name));
    const dropped = [];
    if (names.has('id_1')) {
      await col.dropIndex('id_1');
      dropped.push('id_1');
    }
    if (names.has('address_1')) {
      await col.dropIndex('address_1');
      dropped.push('address_1');
    }
    // Ensure a helpful non-unique index exists
    try {
      await col.createIndex({ contractId: 1 }, { unique: false, name: 'contractId_1' });
    } catch {}

    const after = (await col.indexes()).map(ix => ({ name: ix.name, key: ix.key, unique: !!ix.unique }));
    res.set('Cache-Control', 'no-store');
    return res.json({ ok: true, dropped, before, after });
  } catch (e) {
    return res.status(500).json({ ok: false, error: String(e && e.message) });
  }
});

// Auth (nonce + verify)
app.get('/api/auth', (req, res) => {
  const { action, walletAddress } = req.query;
  if (action !== 'nonce') return res.status(400).json({ error: 'Invalid action' });
  if (!walletAddress || !/^0x[a-fA-F0-9]{40}$/.test(walletAddress)) return res.status(400).json({ error: 'Invalid wallet address' });

  const nonce = randomBytes(16).toString('hex');
  const timestamp = Date.now();
  const message = `Welcome to Squdy Platform!\n\nThis request will not trigger a blockchain transaction or cost any gas fees.\n\nWallet: ${walletAddress}\nNonce: ${nonce}\nTimestamp: ${timestamp}\n\nSign this message to authenticate your wallet.`;
  res.json({ message, nonce, timestamp, walletAddress: walletAddress.toLowerCase() });
});

app.post('/api/auth', (req, res) => {
  const { message, signature, walletAddress } = req.body || {};
  if (!message || !signature || !walletAddress) return res.status(400).json({ error: 'Missing required fields' });
  if (!/^0x[a-fA-F0-9]{40}$/.test(walletAddress)) return res.status(400).json({ error: 'Invalid wallet address' });

  let recovered;
  try { recovered = ethers.utils.verifyMessage(message, signature); } catch { return res.status(400).json({ error: 'Invalid signature', verified: false }); }
  if (recovered.toLowerCase() !== walletAddress.toLowerCase()) return res.status(400).json({ error: 'Signature verification failed', verified: false });

  const adminWallets = (process.env.ADMIN_WALLETS || '').split(',').map(w => w.trim().toLowerCase()).filter(Boolean);
  const isAdmin = adminWallets.includes(walletAddress.toLowerCase());
  res.json({ verified: true, walletAddress: walletAddress.toLowerCase(), isAdmin, timestamp: Date.now() });
});

export default app;

// Temporary admin diagnostic: verify MongoDB insert works (will be removed for production)
// Path kept outside Express app export to ensure Vercel picks it up correctly with this file-based function
app.get('/api/admin/db-test', async (req, res) => {
  try {
    const col = await getCampaignsCollection();
    const doc = { _type: 'diagnostic', createdAt: new Date().toISOString() };
    const result = await col.insertOne(doc);
    res.set('Cache-Control', 'no-store');
    return res.json({ ok: true, insertedId: String(result.insertedId) });
  } catch (e) {
    return res.json({ ok: false, hasUri: !!process.env.MONGODB_URI, error: String(e && e.message), stack: String(e && e.stack) });
  }
});