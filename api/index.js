// Vercel serverless function for Squdy backend (consolidated, ESM)
import express from 'express';
import cors from 'cors';
import { ethers } from 'ethers';
import { randomBytes } from 'crypto';
import { getDatabase } from './lib/mongodb.js';

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// Health endpoint
app.get('/api/health', async (req, res) => {
  let mongoStatus = 'unknown';
  let mongoError = null;
  let mongoInfo = {};
  
  try {
    if (!process.env.MONGODB_URI) {
      mongoStatus = 'no_uri';
    } else {
      const db = await getDatabase();
      const col = db.collection('campaigns');
      const count = await col.countDocuments({});
      const sample = await col.findOne({});
      mongoStatus = 'connected';
      mongoInfo = {
        dbName: db.databaseName,
        totalCampaigns: count,
        sampleCampaign: sample ? {
          id: sample._id,
          name: sample.name,
          contractId: sample.contractId,
          contractIdType: typeof sample.contractId
        } : null
      };
    }
  } catch (e) {
    mongoStatus = 'error';
    mongoError = e.message;
  }
  
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    mongodb: {
      status: mongoStatus,
      error: mongoError,
      info: mongoInfo
    }
  });
});

// In-memory demo campaigns (ephemeral fallback when DB empty)
const demoCampaigns = [1,2,3,4,5].map((i) => ({
    id: i,
    contractId: i,
    name: `Demo Campaign ${i}`,
    description: 'Demo campaign generated by backend.',
    imageUrl: 'https://images.unsplash.com/photo-1640340434855-6084b1f4901c?w=800&h=400&fit=crop',
    status: 'active',
    currentAmount: 0,
    hardCap: 50000,
    participantCount: 0,
    softCap: 5000,
    ticketAmount: 100,
    startDate: new Date().toISOString(),
    endDate: new Date(Date.now() + 7*24*60*60*1000).toISOString(),
    prizes: [
      { name: 'First Prize', description: 'Winner takes all', value: '10000', currency: 'USD', quantity: 1 },
      { name: 'Second Prize', description: 'Runner up reward', value: '5000', currency: 'USD', quantity: 1 },
      { name: 'Third Prize', description: 'Bronze medal', value: '2500', currency: 'USD', quantity: 1 },
    ],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
}));

let campaignsInMemory = [...demoCampaigns];

async function getCampaignsCollection() {
  const db = await getDatabase();
  return db.collection('campaigns');
}

// Campaigns list
app.get(['/api/campaigns','/campaigns'], async (req, res) => {
  try {
    const limit = parseInt(req.query.limit || '10', 10);
    const page = 1;

    const col = await getCampaignsCollection();
    const filter = { name: { $exists: true } };
    const total = await col.countDocuments(filter);
    let campaigns = [];

    if (total > 0) {
      const raw = await col
        .find(filter)
        .sort({ createdAt: -1 })
        .limit(limit * 3) // fetch extra and filter client-side to ensure valid items
        .toArray();
      // Keep only campaigns with a numeric contractId which our UI uses as key/route
      campaigns = raw
        .filter((c) => typeof c.contractId === 'number' && Number.isFinite(c.contractId))
        .slice(0, limit)
        .map((c) => ({
          participantCount: 0,
          status: c.status || 'active',
          imageUrl: c.imageUrl || 'https://images.unsplash.com/photo-1640340434855-6084b1f4901c?w=800&h=400&fit=crop',
          ...c,
        }));
    }
    
    // If no valid campaigns from MongoDB, use in-memory as fallback
    if (campaigns.length === 0) {
      campaigns = campaignsInMemory.slice(0, limit);
    }
    
    // For demo purposes, always ensure at least one campaign appears
    if (campaigns.length === 0) {
      campaigns = [{
        id: 999,
        contractId: 999,
        name: "Demo Campaign (Persistent)",
        description: "A demo campaign that always appears for testing",
        imageUrl: "https://images.unsplash.com/photo-1640340434855-6084b1f4901c?w=800&h=400&fit=crop",
        softCap: 10000,
        hardCap: 50000,
        ticketAmount: 100,
        currentAmount: 15000,
        startDate: new Date().toISOString(),
        endDate: new Date(Date.now() + 7*24*60*60*1000).toISOString(),
        status: "active",
        participantCount: 42,
        prizes: ["1st Prize: 50% of pool", "2nd Prize: 30% of pool", "3rd Prize: 20% of pool"],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      }];
    }

    res.set('Cache-Control', 'no-store');
    res.json({
      campaigns,
      pagination: { page, limit, total: total || campaignsInMemory.length, totalPages: 1 }
    });
  } catch (e) {
    console.error('List campaigns error, using fallback:', e);
    // Fallback to in-memory campaigns on any error
    const campaigns = campaignsInMemory.slice(0, parseInt(req.query.limit || '10', 10));
    res.set('Cache-Control', 'no-store');
    res.json({
      campaigns,
      pagination: { page: 1, limit: 10, total: campaignsInMemory.length, totalPages: 1 }
    });
  }
});

// Debug: list registered routes
app.get('/api/routes', (req, res) => {
  const routes = [];
  app._router.stack.forEach((middleware) => {
    if (middleware.route) {
      const methods = Object.keys(middleware.route.methods)
        .filter((m) => middleware.route.methods[m])
        .map((m) => m.toUpperCase());
      routes.push({ path: middleware.route.path, methods });
    } else if (middleware.name === 'router' && middleware.handle.stack) {
      middleware.handle.stack.forEach((handler) => {
        const route = handler.route;
        if (route) {
          const methods = Object.keys(route.methods)
            .filter((m) => route.methods[m])
            .map((m) => m.toUpperCase());
          routes.push({ path: route.path, methods });
        }
      });
    }
  });
  res.json({ routes });
});

// Admin stats (Mongo optional)
app.get(['/api/admin/stats','/admin/stats'], async (req, res) => {
  try {
    const stats = {
      platform: { totalCampaigns: 0, activeCampaigns: 0, totalParticipants: 0, totalRaised: 0, status: 'operational' },
      blockchain: {
        network: process.env.VITE_NETWORK || 'sepolia',
        chainId: process.env.VITE_CHAIN_ID || '11155111',
        squdyTokenAddress: process.env.VITE_SQUDY_TOKEN_ADDRESS,
        campaignManagerAddress: process.env.VITE_CAMPAIGN_MANAGER_ADDRESS,
        connected: true,
      },
      database: { status: 'unknown', lastCheck: new Date().toISOString() },
    };
    res.json({ stats });
  } catch (e) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Admin create campaign (mock; ephemeral) - include alternate path to avoid any platform routing quirks
async function handleCreateCampaign(req, res) {
  const data = req.body || {};
  if (!data.name || !data.description || !data.softCap || !data.hardCap || !data.ticketAmount) {
    return res.status(400).json({ error: 'Missing required fields' });
  }
  const nowIso = new Date().toISOString();
  try {
    const col = await getCampaignsCollection();
    const last = await col.find({ contractId: { $type: 'number' } }).sort({ contractId: -1 }).limit(1).toArray();
    const nextId = last.length && typeof last[0].contractId === 'number' ? (last[0].contractId + 1) : 1;

    const newCampaign = {
      id: nextId,
      contractId: nextId,
      name: data.name,
      description: data.description,
      imageUrl: data.imageUrl || 'https://images.unsplash.com/photo-1640340434855-6084b1f4901c?w=800&h=400&fit=crop',
      status: 'active',
      currentAmount: 0,
      hardCap: Number(data.hardCap),
      participantCount: 0,
      softCap: Number(data.softCap),
      ticketAmount: Number(data.ticketAmount),
      startDate: data.startDate || nowIso,
      endDate: data.endDate || new Date(Date.now() + 7*24*60*60*1000).toISOString(),
      prizes: data.prizes || [],
      createdAt: nowIso,
      updatedAt: nowIso,
    };

    await col.insertOne(newCampaign);

    // Keep in-memory fallback updated (useful if DB temporarily unavailable later)
    campaignsInMemory = [newCampaign, ...campaignsInMemory];

    res.set('Cache-Control', 'no-store');
    return res.status(201).json({ message: 'Campaign created', campaign: newCampaign });
  } catch (e) {
    console.error('Create campaign error, falling back to memory:', e);
    const newCampaign = {
      id: campaignsInMemory.length + 1,
      contractId: campaignsInMemory.length + 1,
      name: data.name,
      description: data.description,
      imageUrl: data.imageUrl || 'https://images.unsplash.com/photo-1640340434855-6084b1f4901c?w=800&h=400&fit=crop',
      status: 'active',
      currentAmount: 0,
      hardCap: Number(data.hardCap),
      participantCount: 0,
      softCap: Number(data.softCap),
      ticketAmount: Number(data.ticketAmount),
      startDate: data.startDate || nowIso,
      endDate: data.endDate || new Date(Date.now() + 7*24*60*60*1000).toISOString(),
      prizes: data.prizes || [],
      createdAt: nowIso,
      updatedAt: nowIso,
    };
    campaignsInMemory = [newCampaign, ...campaignsInMemory];
    res.set('Cache-Control', 'no-store');
    return res.status(201).json({ message: 'Campaign created (fallback)', campaign: newCampaign });
  }
}

app.post(['/api/admin/campaigns','/admin/campaigns','/api/admin-create-campaign'], (req, res) => {
  return handleCreateCampaign(req, res);
});

// Fallback create on public path to avoid any admin routing quirks on Vercel
app.post(['/api/campaigns','/campaigns'], (req, res) => {
  return handleCreateCampaign(req, res);
});

// Temporary compatibility endpoint to bypass POST issues on Vercel routing
app.get('/api/create-campaign', (req, res) => {
  const data = {
    name: req.query.name,
    description: req.query.description,
    softCap: Number(req.query.softCap),
    hardCap: Number(req.query.hardCap),
    ticketAmount: Number(req.query.ticketAmount),
    startDate: req.query.startDate,
    endDate: req.query.endDate,
  };
  return handleCreateCampaign({ body: data }, res);
});

// Debug route to verify Vercel routing for this path
app.get(['/api/admin/campaigns','/admin/campaigns','/api/admin-create-campaign'], async (req, res) => {
  try {
    const db = await getDatabase();
    const col = db.collection('campaigns');
    const allRaw = await col.find({}).toArray();
    const withName = await col.find({ name: { $exists: true } }).toArray();
    const withNumericId = await col.find({ contractId: { $type: 'number' } }).toArray();
    
    return res.status(200).json({ 
      ok: true, 
      path: req.path,
      debug: {
        totalInDB: allRaw.length,
        withName: withName.length,
        withNumericId: withNumericId.length,
        sampleDocs: allRaw.map(doc => ({
          _id: doc._id,
          name: doc.name,
          contractId: doc.contractId,
          contractIdType: typeof doc.contractId
        }))
      }
    });
  } catch (e) {
    return res.status(200).json({ ok: false, error: e.message });
  }
});

// Allow CORS preflight on admin campaigns path
app.options(['/api/admin/campaigns','/admin/campaigns','/api/admin-create-campaign','/api/campaigns','/campaigns'], (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  return res.status(200).end();
});

// Single campaign
app.get(['/api/campaigns/:id','/campaigns/:id'], async (req, res) => {
  const id = Number(req.params.id);
  try {
    const col = await getCampaignsCollection();
    const byContract = await col.findOne({ contractId: id });
    if (byContract) {
      res.set('Cache-Control', 'no-store');
      return res.json({ campaign: byContract });
    }
  } catch (e) {
    console.error('Read single campaign DB error:', e);
  }
  const fallback = campaignsInMemory.find(c => c.id === id || c.contractId === id);
  if (!fallback) return res.status(404).json({ error: 'Campaign not found' });
  res.set('Cache-Control', 'no-store');
  return res.json({ campaign: fallback });
});

// My status for campaign (mock)
app.get(['/api/campaigns/:id/my-status','/campaigns/:id/my-status'], (req, res) => {
  return res.json({ isParticipating: false, status: null, stakeAmount: 0, socialTasks: {} });
});

// Auth (nonce + verify)
app.get('/api/auth', (req, res) => {
  const { action, walletAddress } = req.query;
  if (action !== 'nonce') return res.status(400).json({ error: 'Invalid action' });
  if (!walletAddress || !/^0x[a-fA-F0-9]{40}$/.test(walletAddress)) return res.status(400).json({ error: 'Invalid wallet address' });

  const nonce = randomBytes(16).toString('hex');
  const timestamp = Date.now();
  const message = `Welcome to Squdy Platform!\n\nThis request will not trigger a blockchain transaction or cost any gas fees.\n\nWallet: ${walletAddress}\nNonce: ${nonce}\nTimestamp: ${timestamp}\n\nSign this message to authenticate your wallet.`;
  res.json({ message, nonce, timestamp, walletAddress: walletAddress.toLowerCase() });
});

app.post('/api/auth', (req, res) => {
  const { message, signature, walletAddress } = req.body || {};
  if (!message || !signature || !walletAddress) return res.status(400).json({ error: 'Missing required fields' });
  if (!/^0x[a-fA-F0-9]{40}$/.test(walletAddress)) return res.status(400).json({ error: 'Invalid wallet address' });

  let recovered;
  try { recovered = ethers.utils.verifyMessage(message, signature); } catch { return res.status(400).json({ error: 'Invalid signature', verified: false }); }
  if (recovered.toLowerCase() !== walletAddress.toLowerCase()) return res.status(400).json({ error: 'Signature verification failed', verified: false });

  const adminWallets = (process.env.ADMIN_WALLETS || '').split(',').map(w => w.trim().toLowerCase()).filter(Boolean);
  const isAdmin = adminWallets.includes(walletAddress.toLowerCase());
  res.json({ verified: true, walletAddress: walletAddress.toLowerCase(), isAdmin, timestamp: Date.now() });
});

export default app;